<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="Lindsey Smith"><meta name="description" content="My name is Lindsey and I work as a full stack software engineer, currently getting my hands dirty with Python and JavaScript at Udacity. I wrote pretty frequently about my time at Hack Reactor, a software engineering bootcamp. Now I blog a mixture of programming, women in tech, life, and cats."><title>Time Complexity in Algorithms&nbsp;&mdash; Leaena.com</title><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="config.title" type="application/atom.xml"><link href="http://fonts.googleapis.com/css?family=Open+Sans:400" rel="stylesheet"><link href="http://fonts.googleapis.com/css?family=Source+Code+Pro:400,600" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/stylesheets/app.css"></head><body><header id="page-header"><div id="masthead"><h1 id="site-title"><a href="/">Leaena.com</a></h1><p id="site-slogan">Coding, cats, California, feminism, and zombies. Your average girl blogger.</p></div></header><section id="content"><article class="post"><h2>Time Complexity in Algorithms</h2><div class="meta">Nov 29 2013 in <a href="/categories/Programming/">Programming</a>&ensp;</div><p>Time complexity is a useful concept in programming. It’s essential for job interviews, but beyond that to really be a good programmer you need to know how cumbersome your algorithm is going to be. For 10 items, something that takes 2 seconds per item is only 20 seconds, but what if you have a million items?</p>
<p>In general, time complexity is measured by how long it takes a number of items (n) to be processed. It is the relationship between the number of things you have to do and the work to be done. Something that takes the same amount of time no matter have much of it you have to do, would be constant time. If I had 10 items or 1 million it would only take me 2 seconds to process. On another extreme is something called the handshake problem. If you only have two people in a room they only have to shake one another’s hands (one handshake). If you have 10 people, they each shake 9 other hands (55 handshakes total, we’ll get to the math in a moment). This is quadratic time.</p>
<p>Here’s a visual of the common programming time complexities:</p>
<p><img src="/images/" alt="bigo"></p>
<p>&nbsp;</p>
<p>Lets start with <strong>constant time</strong> again. In programming, constant time is like deciding whether a number is even or odd:</p>
<pre><code> n % <span class="number">2</span> = ? `&lt;/pre&gt;
This <span class="keyword">is</span> just one expression. You <span class="command">run</span> <span class="keyword">and</span> you're done. It's always going <span class="keyword">to</span> take a certain amount <span class="keyword">of</span> <span class="property">time</span>, no matter what n you give <span class="keyword">it</span>. &lt;span style=<span class="string">"text-decoration: underline;"</span>&gt;In big O notation we would <span class="command">write</span> this <span class="keyword">as</span> O(<span class="number">1</span>).&lt;/span&gt;

Next, <span class="keyword">my</span> favorite, <span class="keyword">as</span> far <span class="keyword">as</span> understanding goes. **Linear <span class="property">time</span>.** In programming, linear <span class="property">time</span>, <span class="keyword">is</span> like <span class="property">running</span> <span class="keyword">through</span> a loop <span class="keyword">of</span> n numbers <span class="keyword">and</span> doing something.
&lt;pre&gt;` <span class="keyword">for</span>( var i = <span class="number">0</span>; i &amp;lt; n; i++ ){
   do something..
 }`&lt;/pre&gt;
The more things ('n's) you have, <span class="keyword">the</span> longer <span class="keyword">the</span> algorithm <span class="keyword">is</span> going <span class="keyword">to</span> take. It's a <span class="number">1</span>:<span class="number">1</span> ratio. If <span class="number">1</span> thing takes <span class="number">1</span> <span class="keyword">second</span>, <span class="number">2</span> things are going <span class="keyword">to</span> take <span class="number">2</span> seconds. &lt;span style=<span class="string">"text-decoration: underline;"</span>&gt;This <span class="keyword">is</span> O(n).&lt;/span&gt;

**Quadratic <span class="property">time</span>** <span class="keyword">is</span> worse than linear <span class="property">time</span>. It's like <span class="keyword">the</span> handshake problem <span class="keyword">or</span> <span class="keyword">in</span> programming terms a <span class="keyword">for</span> loop within a <span class="keyword">for</span> loop. For each n we need <span class="keyword">to</span> <span class="command">run</span> <span class="keyword">through</span> all <span class="keyword">the</span> numbers <span class="number">1</span> <span class="keyword">through</span> n.
&lt;pre&gt;` <span class="keyword">for</span>( var i = <span class="number">0</span>; i &amp;lt; n; i++ ){
   <span class="keyword">for</span>( var j = <span class="number">0</span>; j &amp;lt; n; j++ ){
     do something..
   }
 }`&lt;/pre&gt;
Each n thing <span class="keyword">is</span> done n <span class="keyword">times</span>. &lt;span style=<span class="string">"text-decoration: underline;"</span>&gt;This <span class="keyword">is</span> n * n <span class="keyword">or</span> <span class="keyword">in</span> big O terms O(n&lt;sup&gt;<span class="number">2</span>&lt;/sup&gt;).&lt;/span&gt;

**Logarithmic <span class="property">time</span>** <span class="keyword">is</span> all kinds <span class="keyword">of</span> magic. It tapers off <span class="keyword">to</span> a near <span class="type">constant</span> <span class="keyword">for</span> larger 'n's. This <span class="keyword">is</span> possible because <span class="keyword">of</span> <span class="keyword">the</span> magic <span class="keyword">of</span> halves. In a binary search tree there are only two options <span class="keyword">to</span> descend, left (options lower than <span class="keyword">the</span> current value) <span class="keyword">or</span> right (options higher than <span class="keyword">the</span> current value). Either choice will cut off roughly half <span class="keyword">of</span> all <span class="keyword">the</span> possible values. On <span class="keyword">the</span> next level, you have <span class="keyword">the</span> same choice, either you've found your value, <span class="keyword">or</span> you go left <span class="keyword">or</span> right, halving your options again.
&lt;pre&gt;` <span class="keyword">while</span> ( low &amp;lt;= high ) {
   var mid = ( low + high ) / <span class="number">2</span>;
   <span class="keyword">if</span> ( target &amp;lt; <span class="type">list</span>[mid] ){
     var high = mid - <span class="number">1</span>;    
   } <span class="keyword">else</span> <span class="keyword">if</span> ( target &amp;gt; <span class="type">list</span>[mid] ){
     var low = mid + <span class="number">1</span>;
   } <span class="keyword">else</span> { break; }
 }
</code></pre><p>If you’re constantly halving the amount of things you have to check, eventually you hit a roughly constant time for an n search. <span style="text-decoration: underline;">This is O(log n).</span></p>
<p><em>This post has been brought to you by <a href="http://www.daniweb.com/software-development/computer-science/threads/13488/time-complexity-of-algorithm" target="_blank" rel="external">a forum post on time complexity</a>, bits and pieces of <a href="http://en.wikipedia.org/wiki/Time_complexity" target="_blank" rel="external">the wiki article on time complexity</a>, and <a href="https://www.youtube.com/watch?v=sh4O6DRs26M" target="_blank" rel="external">this inspirational code class ad featuring my lead instructor from his Twitter days</a>.</em></p>
</article><nav id="article-pagination"><a href="/2013/11/inside-my-head-learning-javascript/" title="Previous article: Inside My Head: Learning Java Script" class="prev">&larr; Previous article</a><a href="/2013/11/week-3-less-work-more-work/" title="Next article: Week 3   Less Work, More... Work?" class="next">Next article &rarr;</a></nav></section><footer id="page-footer"><section><nav id="footer-menu"><ul><li><a href="/about">About</a></li><li><a href="/archives">Archive</a></li><li><a href="http://github.com/leaena/leaena.github.io">Source</a></li><li><a href="/atom.xml">Feed</a></li></ul></nav></section></footer></body></html>